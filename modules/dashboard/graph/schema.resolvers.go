package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.63

import (
	"context"
	"slices"
	"time"

	"github.com/99designs/gqlgen/graphql/handler/transport"
	"github.com/kubetail-org/kubetail/modules/dashboard/graph/model"
	"github.com/kubetail-org/kubetail/modules/dashboard/internal/k8shelpers"
	"github.com/kubetail-org/kubetail/modules/shared/config"
	gqlerrors "github.com/kubetail-org/kubetail/modules/shared/graphql/errors"
	"github.com/kubetail-org/kubetail/modules/shared/helm"
	sharedk8shelpers "github.com/kubetail-org/kubetail/modules/shared/k8shelpers"
	"helm.sh/helm/v3/pkg/release"
	appsv1 "k8s.io/api/apps/v1"
	batchv1 "k8s.io/api/batch/v1"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/watch"
	"k8s.io/client-go/tools/clientcmd/api"
	"k8s.io/utils/ptr"
)

// Object is the resolver for the object field.
func (r *appsV1DaemonSetsWatchEventResolver) Object(ctx context.Context, obj *watch.Event) (*appsv1.DaemonSet, error) {
	return typeassertRuntimeObject[*appsv1.DaemonSet](obj.Object)
}

// Object is the resolver for the object field.
func (r *appsV1DeploymentsWatchEventResolver) Object(ctx context.Context, obj *watch.Event) (*appsv1.Deployment, error) {
	return typeassertRuntimeObject[*appsv1.Deployment](obj.Object)
}

// Object is the resolver for the object field.
func (r *appsV1ReplicaSetsWatchEventResolver) Object(ctx context.Context, obj *watch.Event) (*appsv1.ReplicaSet, error) {
	return typeassertRuntimeObject[*appsv1.ReplicaSet](obj.Object)
}

// Object is the resolver for the object field.
func (r *appsV1StatefulSetsWatchEventResolver) Object(ctx context.Context, obj *watch.Event) (*appsv1.StatefulSet, error) {
	return typeassertRuntimeObject[*appsv1.StatefulSet](obj.Object)
}

// Object is the resolver for the object field.
func (r *batchV1CronJobsWatchEventResolver) Object(ctx context.Context, obj *watch.Event) (*batchv1.CronJob, error) {
	return typeassertRuntimeObject[*batchv1.CronJob](obj.Object)
}

// Object is the resolver for the object field.
func (r *batchV1JobsWatchEventResolver) Object(ctx context.Context, obj *watch.Event) (*batchv1.Job, error) {
	return typeassertRuntimeObject[*batchv1.Job](obj.Object)
}

// Object is the resolver for the object field.
func (r *coreV1NamespacesWatchEventResolver) Object(ctx context.Context, obj *watch.Event) (*corev1.Namespace, error) {
	return typeassertRuntimeObject[*corev1.Namespace](obj.Object)
}

// Object is the resolver for the object field.
func (r *coreV1NodesWatchEventResolver) Object(ctx context.Context, obj *watch.Event) (*corev1.Node, error) {
	return typeassertRuntimeObject[*corev1.Node](obj.Object)
}

// Object is the resolver for the object field.
func (r *coreV1PodsWatchEventResolver) Object(ctx context.Context, obj *watch.Event) (*corev1.Pod, error) {
	return typeassertRuntimeObject[*corev1.Pod](obj.Object)
}

// Object is the resolver for the object field.
func (r *coreV1ServicesWatchEventResolver) Object(ctx context.Context, obj *watch.Event) (*corev1.Service, error) {
	return typeassertRuntimeObject[*corev1.Service](obj.Object)
}

// AuthInfos is the resolver for the authInfos field.
func (r *kubeConfigResolver) AuthInfos(ctx context.Context, obj *model.KubeConfig) ([]*model.KubeConfigAuthInfo, error) {
	outList := make([]*model.KubeConfigAuthInfo, len(obj.Config.Clusters))
	i := 0
	for name, val := range obj.Config.AuthInfos {
		outList[i] = &model.KubeConfigAuthInfo{
			AuthInfo: val,
			Name:     name,
		}
		i += 1
	}
	return outList, nil
}

// Clusters is the resolver for the clusters field.
func (r *kubeConfigResolver) Clusters(ctx context.Context, obj *model.KubeConfig) ([]*model.KubeConfigCluster, error) {
	outList := make([]*model.KubeConfigCluster, len(obj.Config.Clusters))
	i := 0
	for name, val := range obj.Config.Clusters {
		outList[i] = &model.KubeConfigCluster{
			Cluster: val,
			Name:    name,
		}
		i += 1
	}
	return outList, nil
}

// Contexts is the resolver for the contexts field.
func (r *kubeConfigResolver) Contexts(ctx context.Context, obj *model.KubeConfig) ([]*model.KubeConfigContext, error) {
	outList := make([]*model.KubeConfigContext, len(obj.Config.Clusters))
	i := 0
	for name, val := range obj.Config.Contexts {
		outList[i] = &model.KubeConfigContext{
			Context: val,
			Name:    name,
		}
		i += 1
	}
	return outList, nil
}

// HelmInstallLatest is the resolver for the helmInstallLatest field.
func (r *mutationResolver) HelmInstallLatest(ctx context.Context, kubeContext *string) (*release.Release, error) {
	// Reject requests not in desktop environment
	if r.environment != config.EnvironmentDesktop {
		return nil, gqlerrors.ErrForbidden
	}

	// Init client
	client, err := helm.NewClient(ptr.Deref(kubeContext, ""))
	if err != nil {
		return nil, err
	}

	// Install
	release, err := client.InstallLatest(helm.DefaultNamespace, helm.DefaultReleaseName)
	if err != nil {
		return nil, err
	}

	return release, nil
}

// AppsV1DaemonSetsGet is the resolver for the appsV1DaemonSetsGet field.
func (r *queryResolver) AppsV1DaemonSetsGet(ctx context.Context, kubeContext *string, namespace *string, name string, options *metav1.GetOptions) (*appsv1.DaemonSet, error) {
	// Deref namespace
	ns, err := sharedk8shelpers.DerefNamespace(r.allowedNamespaces, namespace, r.cm.GetDefaultNamespace(kubeContext))
	if err != nil {
		return nil, err
	}

	// Get client
	clientset, err := r.cm.GetOrCreateClientset(kubeContext)
	if err != nil {
		return nil, err
	}

	// Execute
	return clientset.AppsV1().DaemonSets(ns).Get(ctx, name, toGetOptions(options))
}

// AppsV1DaemonSetsList is the resolver for the appsV1DaemonSetsList field.
func (r *queryResolver) AppsV1DaemonSetsList(ctx context.Context, kubeContext *string, namespace *string, options *metav1.ListOptions) (*appsv1.DaemonSetList, error) {
	outList := &appsv1.DaemonSetList{}
	if err := r.listResource(ctx, kubeContext, namespace, options, outList); err != nil {
		return nil, err
	}
	return outList, nil
}

// AppsV1DeploymentsGet is the resolver for the appsV1DeploymentsGet field.
func (r *queryResolver) AppsV1DeploymentsGet(ctx context.Context, kubeContext *string, namespace *string, name string, options *metav1.GetOptions) (*appsv1.Deployment, error) {
	// Deref namespace
	ns, err := sharedk8shelpers.DerefNamespace(r.allowedNamespaces, namespace, r.cm.GetDefaultNamespace(kubeContext))
	if err != nil {
		return nil, err
	}

	// Get client
	clientset, err := r.cm.GetOrCreateClientset(kubeContext)
	if err != nil {
		return nil, err
	}

	// Execute
	return clientset.AppsV1().Deployments(ns).Get(ctx, name, toGetOptions(options))
}

// AppsV1DeploymentsList is the resolver for the appsV1DeploymentsList field.
func (r *queryResolver) AppsV1DeploymentsList(ctx context.Context, kubeContext *string, namespace *string, options *metav1.ListOptions) (*appsv1.DeploymentList, error) {
	outList := &appsv1.DeploymentList{}
	if err := r.listResource(ctx, kubeContext, namespace, options, outList); err != nil {
		return nil, err
	}
	return outList, nil
}

// AppsV1ReplicaSetsGet is the resolver for the appsV1ReplicaSetsGet field.
func (r *queryResolver) AppsV1ReplicaSetsGet(ctx context.Context, kubeContext *string, namespace *string, name string, options *metav1.GetOptions) (*appsv1.ReplicaSet, error) {
	// Deref namespace
	ns, err := sharedk8shelpers.DerefNamespace(r.allowedNamespaces, namespace, r.cm.GetDefaultNamespace(kubeContext))
	if err != nil {
		return nil, err
	}

	// Get client
	clientset, err := r.cm.GetOrCreateClientset(kubeContext)
	if err != nil {
		return nil, err
	}

	// Execute
	return clientset.AppsV1().ReplicaSets(ns).Get(ctx, name, toGetOptions(options))
}

// AppsV1ReplicaSetsList is the resolver for the appsV1ReplicaSetsList field.
func (r *queryResolver) AppsV1ReplicaSetsList(ctx context.Context, kubeContext *string, namespace *string, options *metav1.ListOptions) (*appsv1.ReplicaSetList, error) {
	outList := &appsv1.ReplicaSetList{}
	if err := r.listResource(ctx, kubeContext, namespace, options, outList); err != nil {
		return nil, err
	}
	return outList, nil
}

// AppsV1StatefulSetsGet is the resolver for the appsV1StatefulSetsGet field.
func (r *queryResolver) AppsV1StatefulSetsGet(ctx context.Context, kubeContext *string, namespace *string, name string, options *metav1.GetOptions) (*appsv1.StatefulSet, error) {
	// Deref namespace
	ns, err := sharedk8shelpers.DerefNamespace(r.allowedNamespaces, namespace, r.cm.GetDefaultNamespace(kubeContext))
	if err != nil {
		return nil, err
	}

	// Get client
	clientset, err := r.cm.GetOrCreateClientset(kubeContext)
	if err != nil {
		return nil, err
	}

	// Execute
	return clientset.AppsV1().StatefulSets(ns).Get(ctx, name, toGetOptions(options))
}

// AppsV1StatefulSetsList is the resolver for the appsV1StatefulSetsList field.
func (r *queryResolver) AppsV1StatefulSetsList(ctx context.Context, kubeContext *string, namespace *string, options *metav1.ListOptions) (*appsv1.StatefulSetList, error) {
	outList := &appsv1.StatefulSetList{}
	if err := r.listResource(ctx, kubeContext, namespace, options, outList); err != nil {
		return nil, err
	}
	return outList, nil
}

// BatchV1CronJobsGet is the resolver for the batchV1CronJobsGet field.
func (r *queryResolver) BatchV1CronJobsGet(ctx context.Context, kubeContext *string, namespace *string, name string, options *metav1.GetOptions) (*batchv1.CronJob, error) {
	// Deref namespace
	ns, err := sharedk8shelpers.DerefNamespace(r.allowedNamespaces, namespace, r.cm.GetDefaultNamespace(kubeContext))
	if err != nil {
		return nil, err
	}

	// Get client
	clientset, err := r.cm.GetOrCreateClientset(kubeContext)
	if err != nil {
		return nil, err
	}

	// Execute
	return clientset.BatchV1().CronJobs(ns).Get(ctx, name, toGetOptions(options))
}

// BatchV1CronJobsList is the resolver for the batchV1CronJobsList field.
func (r *queryResolver) BatchV1CronJobsList(ctx context.Context, kubeContext *string, namespace *string, options *metav1.ListOptions) (*batchv1.CronJobList, error) {
	outList := &batchv1.CronJobList{}
	if err := r.listResource(ctx, kubeContext, namespace, options, outList); err != nil {
		return nil, err
	}
	return outList, nil
}

// BatchV1JobsGet is the resolver for the batchV1JobsGet field.
func (r *queryResolver) BatchV1JobsGet(ctx context.Context, kubeContext *string, namespace *string, name string, options *metav1.GetOptions) (*batchv1.Job, error) {
	// Deref namespace
	ns, err := sharedk8shelpers.DerefNamespace(r.allowedNamespaces, namespace, r.cm.GetDefaultNamespace(kubeContext))
	if err != nil {
		return nil, err
	}

	// Get client
	clientset, err := r.cm.GetOrCreateClientset(kubeContext)
	if err != nil {
		return nil, err
	}

	// Execute
	return clientset.BatchV1().Jobs(ns).Get(ctx, name, toGetOptions(options))
}

// BatchV1JobsList is the resolver for the batchV1JobsList field.
func (r *queryResolver) BatchV1JobsList(ctx context.Context, kubeContext *string, namespace *string, options *metav1.ListOptions) (*batchv1.JobList, error) {
	outList := &batchv1.JobList{}
	if err := r.listResource(ctx, kubeContext, namespace, options, outList); err != nil {
		return nil, err
	}
	return outList, nil
}

// CoreV1NamespacesList is the resolver for the coreV1NamespacesList field.
func (r *queryResolver) CoreV1NamespacesList(ctx context.Context, kubeContext *string, options *metav1.ListOptions) (*corev1.NamespaceList, error) {
	clientset, err := r.cm.GetOrCreateClientset(kubeContext)
	if err != nil {
		return nil, err
	}

	response, err := clientset.CoreV1().Namespaces().List(ctx, toListOptions(options))
	if err != nil {
		return response, nil
	}

	// apply app namespace filter
	if len(r.allowedNamespaces) > 0 {
		items := []corev1.Namespace{}
		for _, item := range response.Items {
			if slices.Contains(r.allowedNamespaces, item.Name) {
				items = append(items, item)
			}
		}
		response.Items = items
	}

	return response, err
}

// CoreV1NodesList is the resolver for the coreV1NodesList field.
func (r *queryResolver) CoreV1NodesList(ctx context.Context, kubeContext *string, options *metav1.ListOptions) (*corev1.NodeList, error) {
	// Get client
	clientset, err := r.cm.GetOrCreateClientset(kubeContext)
	if err != nil {
		return nil, err
	}

	// Execute
	return clientset.CoreV1().Nodes().List(ctx, toListOptions(options))
}

// CoreV1PodsGet is the resolver for the coreV1PodsGet field.
func (r *queryResolver) CoreV1PodsGet(ctx context.Context, kubeContext *string, namespace *string, name string, options *metav1.GetOptions) (*corev1.Pod, error) {
	// Deref namespace
	ns, err := sharedk8shelpers.DerefNamespace(r.allowedNamespaces, namespace, r.cm.GetDefaultNamespace(kubeContext))
	if err != nil {
		return nil, err
	}

	// Get client
	clientset, err := r.cm.GetOrCreateClientset(kubeContext)
	if err != nil {
		return nil, err
	}

	// Execute
	return clientset.CoreV1().Pods(ns).Get(ctx, name, toGetOptions(options))
}

// CoreV1PodsList is the resolver for the coreV1PodsList field.
func (r *queryResolver) CoreV1PodsList(ctx context.Context, kubeContext *string, namespace *string, options *metav1.ListOptions) (*corev1.PodList, error) {
	outList := &corev1.PodList{}
	if err := r.listResource(ctx, kubeContext, namespace, options, outList); err != nil {
		return nil, err
	}
	return outList, nil
}

// CoreV1ServicesGet is the resolver for the coreV1ServicesGet field.
func (r *queryResolver) CoreV1ServicesGet(ctx context.Context, kubeContext *string, namespace *string, name string, options *metav1.GetOptions) (*corev1.Service, error) {
	// Deref namespace
	ns, err := sharedk8shelpers.DerefNamespace(r.allowedNamespaces, namespace, r.cm.GetDefaultNamespace(kubeContext))
	if err != nil {
		return nil, err
	}

	// Get client
	clientset, err := r.cm.GetOrCreateClientset(kubeContext)
	if err != nil {
		return nil, err
	}

	// Execute
	return clientset.CoreV1().Services(ns).Get(ctx, name, toGetOptions(options))
}

// CoreV1ServicesList is the resolver for the coreV1ServicesList field.
func (r *queryResolver) CoreV1ServicesList(ctx context.Context, kubeContext *string, namespace *string, options *metav1.ListOptions) (*corev1.ServiceList, error) {
	outList := &corev1.ServiceList{}
	if err := r.listResource(ctx, kubeContext, namespace, options, outList); err != nil {
		return nil, err
	}
	return outList, nil
}

// ClusterAPIReadyWait is the resolver for the clusterAPIReadyWait field.
func (r *queryResolver) ClusterAPIReadyWait(ctx context.Context, kubeContext *string, namespace *string, serviceName *string) (bool, error) {
	if err := r.hm.ReadyWait(ctx, kubeContext, namespace, serviceName); err != nil {
		return false, err
	}

	if ctx.Err() != nil {
		return false, ctx.Err()
	}

	return true, nil
}

// ClusterAPIHealthzGet is the resolver for the clusterAPIHealthzGet field.
func (r *queryResolver) ClusterAPIHealthzGet(ctx context.Context, kubeContext *string, namespace *string, serviceName *string) (*model.HealthCheckResponse, error) {
	status, err := r.hm.GetHealthStatus(ctx, kubeContext, namespace, serviceName)
	if err != nil {
		return nil, err
	}

	return &model.HealthCheckResponse{
		Status:    healthCheckStatusFromClusterAPIHealthStatus(status),
		Timestamp: time.Now().UTC(),
	}, nil
}

// ClusterAPIServicesList is the resolver for the clusterAPIServicesList field.
func (r *queryResolver) ClusterAPIServicesList(ctx context.Context, kubeContext *string) (*corev1.ServiceList, error) {
	// Reject requests not in desktop environment
	if r.environment != config.EnvironmentDesktop {
		return nil, gqlerrors.ErrForbidden
	}

	options := &metav1.ListOptions{
		LabelSelector: "app.kubernetes.io/name=kubetail,app.kubernetes.io/component=cluster-api",
	}

	outList := &corev1.ServiceList{}
	if err := r.listResource(ctx, kubeContext, sharedk8shelpers.BypassNamespaceCheck, options, outList); err != nil {
		return nil, err
	}

	return outList, nil
}

// HelmListReleases is the resolver for the helmListReleases field.
func (r *queryResolver) HelmListReleases(ctx context.Context, kubeContext *string) ([]*release.Release, error) {
	// Reject requests not in desktop environment
	if r.environment != config.EnvironmentDesktop {
		return nil, gqlerrors.ErrForbidden
	}

	// Init client
	client, err := helm.NewClient(ptr.Deref(kubeContext, ""))
	if err != nil {
		return nil, err
	}

	// Get list
	releases, err := client.ListReleases()
	if err != nil {
		return nil, err
	}

	return releases, nil
}

// KubeConfigGet is the resolver for the kubeConfigGet field.
func (r *queryResolver) KubeConfigGet(ctx context.Context) (*model.KubeConfig, error) {
	// Reject requests not in desktop environment
	if r.environment != config.EnvironmentDesktop {
		return nil, gqlerrors.ErrForbidden
	}

	cm, ok := r.cm.(*k8shelpers.DesktopConnectionManager)
	if !ok {
		return nil, gqlerrors.ErrInternalServerError
	}

	return &model.KubeConfig{Config: cm.GetKubeConfig()}, nil
}

// KubernetesAPIReadyWait is the resolver for the kubernetesAPIReadyWait field.
func (r *queryResolver) KubernetesAPIReadyWait(ctx context.Context, kubeContext *string) (bool, error) {
	ctx, cancel := context.WithTimeout(ctx, 20*time.Second)
	defer cancel()

	// Execute
	if err := r.cm.WaitUntilReady(ctx, kubeContext); err != nil {
		return false, err
	}

	return true, nil
}

// KubernetesAPIHealthzGet is the resolver for the kubernetesAPIHealthzGet field.
func (r *queryResolver) KubernetesAPIHealthzGet(ctx context.Context, kubeContext *string) (*model.HealthCheckResponse, error) {
	return r.kubernetesAPIHealthzGet(ctx, kubeContext), nil
}

// PodLogHead is the resolver for the podLogHead field.
func (r *queryResolver) PodLogHead(ctx context.Context, kubeContext *string, namespace *string, name string, container *string, after *string, since *string, first *int) (*model.PodLogQueryResponse, error) {
	// Deref namespace
	ns, err := sharedk8shelpers.DerefNamespace(r.allowedNamespaces, namespace, r.cm.GetDefaultNamespace(kubeContext))
	if err != nil {
		return nil, err
	}

	// build query args
	args := HeadArgs{}

	if after != nil {
		args.After = *after
	}

	if since != nil {
		args.Since = *since
	}

	if first != nil {
		args.First = uint(*first)
	}

	return r.podLogHead(ctx, kubeContext, ns, name, container, args)
}

// PodLogTail is the resolver for the podLogTail field.
func (r *queryResolver) PodLogTail(ctx context.Context, kubeContext *string, namespace *string, name string, container *string, before *string, last *int) (*model.PodLogQueryResponse, error) {
	// Deref namespace
	ns, err := sharedk8shelpers.DerefNamespace(r.allowedNamespaces, namespace, r.cm.GetDefaultNamespace(kubeContext))
	if err != nil {
		return nil, err
	}

	// build query args
	args := TailArgs{}

	if before != nil {
		args.Before = *before
	}

	if last != nil {
		args.Last = uint(*last)
	}

	return r.podLogTail(ctx, kubeContext, ns, name, container, args)
}

// AppsV1DaemonSetsWatch is the resolver for the appsV1DaemonSetsWatch field.
func (r *subscriptionResolver) AppsV1DaemonSetsWatch(ctx context.Context, kubeContext *string, namespace *string, options *metav1.ListOptions) (<-chan *watch.Event, error) {
	gvr := schema.GroupVersionResource{Group: "apps", Version: "v1", Resource: "daemonsets"}
	return r.watchResourceMulti(ctx, kubeContext, namespace, options, gvr)
}

// AppsV1DeploymentsWatch is the resolver for the appsV1DeploymentsWatch field.
func (r *subscriptionResolver) AppsV1DeploymentsWatch(ctx context.Context, kubeContext *string, namespace *string, options *metav1.ListOptions) (<-chan *watch.Event, error) {
	gvr := schema.GroupVersionResource{Group: "apps", Version: "v1", Resource: "deployments"}
	return r.watchResourceMulti(ctx, kubeContext, namespace, options, gvr)
}

// AppsV1ReplicaSetsWatch is the resolver for the appsV1ReplicaSetsWatch field.
func (r *subscriptionResolver) AppsV1ReplicaSetsWatch(ctx context.Context, kubeContext *string, namespace *string, options *metav1.ListOptions) (<-chan *watch.Event, error) {
	gvr := schema.GroupVersionResource{Group: "apps", Version: "v1", Resource: "replicasets"}
	return r.watchResourceMulti(ctx, kubeContext, namespace, options, gvr)
}

// AppsV1StatefulSetsWatch is the resolver for the appsV1StatefulSetsWatch field.
func (r *subscriptionResolver) AppsV1StatefulSetsWatch(ctx context.Context, kubeContext *string, namespace *string, options *metav1.ListOptions) (<-chan *watch.Event, error) {
	gvr := schema.GroupVersionResource{Group: "apps", Version: "v1", Resource: "statefulsets"}
	return r.watchResourceMulti(ctx, kubeContext, namespace, options, gvr)
}

// BatchV1CronJobsWatch is the resolver for the batchV1CronJobsWatch field.
func (r *subscriptionResolver) BatchV1CronJobsWatch(ctx context.Context, kubeContext *string, namespace *string, options *metav1.ListOptions) (<-chan *watch.Event, error) {
	gvr := schema.GroupVersionResource{Group: "batch", Version: "v1", Resource: "cronjobs"}
	return r.watchResourceMulti(ctx, kubeContext, namespace, options, gvr)
}

// BatchV1JobsWatch is the resolver for the batchV1JobsWatch field.
func (r *subscriptionResolver) BatchV1JobsWatch(ctx context.Context, kubeContext *string, namespace *string, options *metav1.ListOptions) (<-chan *watch.Event, error) {
	gvr := schema.GroupVersionResource{Group: "batch", Version: "v1", Resource: "jobs"}
	return r.watchResourceMulti(ctx, kubeContext, namespace, options, gvr)
}

// CoreV1NamespacesWatch is the resolver for the coreV1NamespacesWatch field.
func (r *subscriptionResolver) CoreV1NamespacesWatch(ctx context.Context, kubeContext *string, options *metav1.ListOptions) (<-chan *watch.Event, error) {
	// Get client
	clientset, err := r.cm.GetOrCreateClientset(kubeContext)
	if err != nil {
		return nil, err
	}

	// Init watch
	watchAPI, err := clientset.CoreV1().Namespaces().Watch(ctx, toListOptions(options))
	if err != nil {
		return nil, err
	}

	// Wrap proxy channel to remove namespaces that aren't allowed
	outCh := make(chan *watch.Event)
	go func() {
		for ev := range watchEventProxyChannel(ctx, watchAPI) {
			ns, err := typeassertRuntimeObject[*corev1.Namespace](ev.Object)
			if err != nil {
				transport.AddSubscriptionError(ctx, gqlerrors.ErrInternalServerError)
				break
			}

			// filter out non-authorized namespaces
			if len(r.allowedNamespaces) == 0 || (len(r.allowedNamespaces) > 0 && slices.Contains(r.allowedNamespaces, ns.Name)) {
				outCh <- ev
			}
		}
		close(outCh)
	}()

	return outCh, nil
}

// CoreV1NodesWatch is the resolver for the coreV1NodesWatch field.
func (r *subscriptionResolver) CoreV1NodesWatch(ctx context.Context, kubeContext *string, options *metav1.ListOptions) (<-chan *watch.Event, error) {
	// Get client
	clientset, err := r.cm.GetOrCreateClientset(kubeContext)
	if err != nil {
		return nil, err
	}

	// Init watch
	watchAPI, err := clientset.CoreV1().Nodes().Watch(ctx, toListOptions(options))
	if err != nil {
		return nil, err
	}

	return watchEventProxyChannel(ctx, watchAPI), nil
}

// CoreV1PodsWatch is the resolver for the coreV1PodsWatch field.
func (r *subscriptionResolver) CoreV1PodsWatch(ctx context.Context, kubeContext *string, namespace *string, options *metav1.ListOptions) (<-chan *watch.Event, error) {
	gvr := schema.GroupVersionResource{Group: "", Version: "v1", Resource: "pods"}
	return r.watchResourceMulti(ctx, kubeContext, namespace, options, gvr)
}

// CoreV1ServicesWatch is the resolver for the coreV1ServicesWatch field.
func (r *subscriptionResolver) CoreV1ServicesWatch(ctx context.Context, kubeContext *string, namespace *string, options *metav1.ListOptions) (<-chan *watch.Event, error) {
	gvr := schema.GroupVersionResource{Group: "", Version: "v1", Resource: "services"}
	return r.watchResourceMulti(ctx, kubeContext, namespace, options, gvr)
}

// KubernetesAPIHealthzWatch is the resolver for the kubernetesAPIHealthzWatch field.
func (r *subscriptionResolver) KubernetesAPIHealthzWatch(ctx context.Context, kubeContext *string) (<-chan *model.HealthCheckResponse, error) {
	outCh := make(chan *model.HealthCheckResponse)

	go func() {
		var lastResponse *model.HealthCheckResponse
		ticker := time.NewTicker(3 * time.Second)

		resp := r.kubernetesAPIHealthzGet(ctx, kubeContext)
		lastResponse = resp
		outCh <- resp

	Loop:
		for {
			select {
			case <-ctx.Done():
				// listener closed connection
				break Loop
			case <-ticker.C:
				resp := r.kubernetesAPIHealthzGet(ctx, kubeContext)
				if lastResponse.Status != resp.Status || !ptr.Equal(lastResponse.Message, resp.Message) {
					lastResponse = resp
					outCh <- resp
				}
			}
		}

		// cleanup
		ticker.Stop()
		close(outCh)
	}()

	return outCh, nil
}

// ClusterAPIHealthzWatch is the resolver for the clusterAPIHealthzWatch field.
func (r *subscriptionResolver) ClusterAPIHealthzWatch(ctx context.Context, kubeContext *string, namespace *string, serviceName *string) (<-chan *model.HealthCheckResponse, error) {
	statusCh, err := r.hm.WatchHealthStatus(ctx, kubeContext, namespace, serviceName)
	if err != nil {
		return nil, err
	}

	outCh := make(chan *model.HealthCheckResponse)

	// Run in go routine
	go func() {
		defer close(outCh)

		for status := range statusCh {
			resp := &model.HealthCheckResponse{
				Status:    healthCheckStatusFromClusterAPIHealthStatus(status),
				Timestamp: time.Now().UTC(),
			}
			outCh <- resp
		}
	}()

	return outCh, nil
}

// ClusterAPIServicesWatch is the resolver for the clusterAPIServicesWatch field.
func (r *subscriptionResolver) ClusterAPIServicesWatch(ctx context.Context, kubeContext *string) (<-chan *watch.Event, error) {
	// Reject requests not in desktop environment
	if r.environment != config.EnvironmentDesktop {
		return nil, gqlerrors.ErrForbidden
	}

	options := &metav1.ListOptions{
		LabelSelector: "app.kubernetes.io/name=kubetail,app.kubernetes.io/component=cluster-api",
	}

	gvr := schema.GroupVersionResource{Group: "", Version: "v1", Resource: "services"}
	return r.watchResourceMulti(ctx, kubeContext, sharedk8shelpers.BypassNamespaceCheck, options, gvr)
}

// KubeConfigWatch is the resolver for the kubeConfigWatch field.
func (r *subscriptionResolver) KubeConfigWatch(ctx context.Context) (<-chan *model.KubeConfigWatchEvent, error) {
	// Reject requests not in desktop environment
	if r.environment != config.EnvironmentDesktop {
		return nil, gqlerrors.ErrForbidden
	}

	cm, ok := r.cm.(*k8shelpers.DesktopConnectionManager)
	if !ok {
		return nil, gqlerrors.ErrInternalServerError
	}

	// Init output channel
	outCh := make(chan *model.KubeConfigWatchEvent)

	// Define handlers
	addedHandler := func(config *api.Config) {
		if ctx.Err() == nil {
			// Send ADDED event
			outCh <- &model.KubeConfigWatchEvent{
				Type:   watch.Added,
				Object: &model.KubeConfig{Config: config},
			}
		}
	}

	modifiedHandler := func(oldConfig *api.Config, newConfig *api.Config) {
		if ctx.Err() == nil {
			// Send MODIFIED event
			outCh <- &model.KubeConfigWatchEvent{
				Type:   watch.Modified,
				Object: &model.KubeConfig{Config: newConfig},
			}
		}
	}

	deletedHandler := func(lastConfig *api.Config) {
		if ctx.Err() == nil {
			// Send DELETED event
			outCh <- &model.KubeConfigWatchEvent{
				Type: watch.Deleted,
			}
		}
	}

	go func() {
		// Close channel and unregister handlers on client close
		defer cm.KubeConfigWatcher.Unsubscribe("ADDED", addedHandler)
		defer cm.KubeConfigWatcher.Unsubscribe("MODIFIED", modifiedHandler)
		defer cm.KubeConfigWatcher.Unsubscribe("DELETED", deletedHandler)
		defer close(outCh)

		// Send initial config
		outCh <- &model.KubeConfigWatchEvent{
			Type:   watch.Added,
			Object: &model.KubeConfig{Config: cm.GetKubeConfig()},
		}

		// Register handlers
		cm.KubeConfigWatcher.Subscribe("ADDED", addedHandler)
		cm.KubeConfigWatcher.Subscribe("MODIFIED", modifiedHandler)
		cm.KubeConfigWatcher.Subscribe("DELETED", deletedHandler)

		// Wait for client close
		<-ctx.Done()
	}()

	return outCh, nil
}

// PodLogFollow is the resolver for the podLogFollow field.
func (r *subscriptionResolver) PodLogFollow(ctx context.Context, kubeContext *string, namespace *string, name string, container *string, after *string, since *string) (<-chan *model.LogRecord, error) {
	// Deref namespace
	ns, err := sharedk8shelpers.DerefNamespace(r.allowedNamespaces, namespace, r.cm.GetDefaultNamespace(kubeContext))
	if err != nil {
		return nil, err
	}

	// build follow args
	args := FollowArgs{}

	if after != nil {
		args.After = *after
	}

	if since != nil {
		args.Since = *since
	}

	// init follow
	inCh, err := r.podLogFollow(ctx, kubeContext, ns, name, container, args)
	if err != nil {
		return nil, err
	}

	// init output channel
	outCh := make(chan *model.LogRecord)

	// forward data from input to output channel
	go func() {
	Loop:
		for record := range inCh {
			select {
			case outCh <- record:
				// wrote to output channel
			case <-ctx.Done():
				// listener closed connection
				break Loop
			}
		}
		close(outCh)
	}()

	return outCh, nil
}

// AppsV1DaemonSetsWatchEvent returns AppsV1DaemonSetsWatchEventResolver implementation.
func (r *Resolver) AppsV1DaemonSetsWatchEvent() AppsV1DaemonSetsWatchEventResolver {
	return &appsV1DaemonSetsWatchEventResolver{r}
}

// AppsV1DeploymentsWatchEvent returns AppsV1DeploymentsWatchEventResolver implementation.
func (r *Resolver) AppsV1DeploymentsWatchEvent() AppsV1DeploymentsWatchEventResolver {
	return &appsV1DeploymentsWatchEventResolver{r}
}

// AppsV1ReplicaSetsWatchEvent returns AppsV1ReplicaSetsWatchEventResolver implementation.
func (r *Resolver) AppsV1ReplicaSetsWatchEvent() AppsV1ReplicaSetsWatchEventResolver {
	return &appsV1ReplicaSetsWatchEventResolver{r}
}

// AppsV1StatefulSetsWatchEvent returns AppsV1StatefulSetsWatchEventResolver implementation.
func (r *Resolver) AppsV1StatefulSetsWatchEvent() AppsV1StatefulSetsWatchEventResolver {
	return &appsV1StatefulSetsWatchEventResolver{r}
}

// BatchV1CronJobsWatchEvent returns BatchV1CronJobsWatchEventResolver implementation.
func (r *Resolver) BatchV1CronJobsWatchEvent() BatchV1CronJobsWatchEventResolver {
	return &batchV1CronJobsWatchEventResolver{r}
}

// BatchV1JobsWatchEvent returns BatchV1JobsWatchEventResolver implementation.
func (r *Resolver) BatchV1JobsWatchEvent() BatchV1JobsWatchEventResolver {
	return &batchV1JobsWatchEventResolver{r}
}

// CoreV1NamespacesWatchEvent returns CoreV1NamespacesWatchEventResolver implementation.
func (r *Resolver) CoreV1NamespacesWatchEvent() CoreV1NamespacesWatchEventResolver {
	return &coreV1NamespacesWatchEventResolver{r}
}

// CoreV1NodesWatchEvent returns CoreV1NodesWatchEventResolver implementation.
func (r *Resolver) CoreV1NodesWatchEvent() CoreV1NodesWatchEventResolver {
	return &coreV1NodesWatchEventResolver{r}
}

// CoreV1PodsWatchEvent returns CoreV1PodsWatchEventResolver implementation.
func (r *Resolver) CoreV1PodsWatchEvent() CoreV1PodsWatchEventResolver {
	return &coreV1PodsWatchEventResolver{r}
}

// CoreV1ServicesWatchEvent returns CoreV1ServicesWatchEventResolver implementation.
func (r *Resolver) CoreV1ServicesWatchEvent() CoreV1ServicesWatchEventResolver {
	return &coreV1ServicesWatchEventResolver{r}
}

// KubeConfig returns KubeConfigResolver implementation.
func (r *Resolver) KubeConfig() KubeConfigResolver { return &kubeConfigResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type appsV1DaemonSetsWatchEventResolver struct{ *Resolver }
type appsV1DeploymentsWatchEventResolver struct{ *Resolver }
type appsV1ReplicaSetsWatchEventResolver struct{ *Resolver }
type appsV1StatefulSetsWatchEventResolver struct{ *Resolver }
type batchV1CronJobsWatchEventResolver struct{ *Resolver }
type batchV1JobsWatchEventResolver struct{ *Resolver }
type coreV1NamespacesWatchEventResolver struct{ *Resolver }
type coreV1NodesWatchEventResolver struct{ *Resolver }
type coreV1PodsWatchEventResolver struct{ *Resolver }
type coreV1ServicesWatchEventResolver struct{ *Resolver }
type kubeConfigResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
